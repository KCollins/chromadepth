<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chromadepth 3D Visualization</title>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load other libraries as needed -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat.gui/0.7.6/dat.gui.min.js"></script>
    <!-- Load app.js after libraries -->
    <script src="app.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 10; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="fileInput" accept=".stl,.glb" />
        <button id="loadButton">Load File</button>
        <button id="resetButton">Reset View</button>
    </div>
    <canvas id="viewport"></canvas>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://threejs.org/examples/js/loaders/STLLoader.js"></script>
    <script>
        let scene, camera, renderer;
        let currentModel = null;
        let controls;

        init();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('viewport') });
            renderer.setSize(window.innerWidth, window.innerHeight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            camera.position.z = 5;

            document.getElementById('loadButton').addEventListener('click', loadModel);
            document.getElementById('resetButton').addEventListener('click', resetView);

            animate();
        }

        function loadModel() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const extension = file.name.split('.').pop().toLowerCase();
                    if (extension === 'glb') {
                        const loader = new THREE.GLTFLoader();
                        loader.parse(event.target.result, '', function(gltf) {
                            if (currentModel) {
                                scene.remove(currentModel);
                            }
                            currentModel = gltf.scene;
                            scene.add(currentModel);
                        });
                    } else if (extension === 'stl') {
                        const loader = new THREE.STLLoader();
                        const geometry = loader.parse(event.target.result);
                        const material = new THREE.MeshNormalMaterial();
                        if (currentModel) {
                            scene.remove(currentModel);
                        }
                        currentModel = new THREE.Mesh(geometry, material);
                        scene.add(currentModel);
                    }
                    adjustCamera();
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function adjustCamera() {
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3()).length();
                const center = box.getCenter(new THREE.Vector3());
                camera.position.copy(center);
                camera.position.z += size;
                camera.lookAt(center);
            }
        }

        function resetView() {
            camera.position.set(0, 0, 5);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (currentModel) {
                currentModel.rotation.y += 0.01;
            }
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
